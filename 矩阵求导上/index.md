
# 矩阵求导术（上） - 知乎

矩阵求导的技术，在统计学、控制论、机器学习等领域有广泛的应用。鉴于我看过的一些资料或言之不详、或繁乱无绪，本文来做个科普，分作两篇，上篇讲标量对矩阵的求导术，下篇讲矩阵对矩阵的求导术。本文使用小写字母x表示标量，粗体小写字母![[公式]](assets/1620480603-157db37c30c20148200a7c1b21426ea7.svg)表示（列）向量，大写字母X表示矩阵。

  

首先来琢磨一下定义，标量f对矩阵X的导数，定义为![[公式]](assets/1620480603-c74be54967c4243ce8b62332491c8c05.svg)，即f对X逐元素求导排成与X尺寸相同的矩阵。然而，这个定义在计算中并不好用，实用上的原因是对函数较复杂的情形难以逐元素求导；哲理上的原因是逐元素求导破坏了**整体性**。试想，为何要将f看做矩阵X而不是各元素![[公式]](assets/1620480603-763d05d8f38878eb2da8fc61ffbb28b3.svg)的函数呢？答案是用矩阵运算更整洁。所以在求导时不宜拆开矩阵，而是要找一个从整体出发的算法。

  

为此，我们来回顾，一元微积分中的导数（标量对标量的导数）与微分有联系：![[公式]](assets/1620480603-90920660c37fd72c74d67e0f4ed6e1a9.svg)；多元微积分中的梯度（标量对向量的导数）也与微分有联系：![[公式]](assets/1620480603-f29bb5c3edf84ac8802db924fb2000be.svg)，这里第一个等号是全微分公式，第二个等号表达了梯度与微分的联系：全微分![[公式]](assets/1620480603-1b8b80a92f47373ed7a9bcd1bbd0cd31.svg)是梯度向量![[公式]](assets/1620480603-9e129c28ee5dd0b3ed905690d10bb85f.svg)(n×1)与微分向量![[公式]](assets/1620480603-9abd2e746a54252fbec2754647363f4f.svg)(n×1)的内积；受此启发，我们将矩阵导数与微分建立联系：![[公式]](assets/1620480603-8c55accce7a13c8e2a91a34bb5b91c47.svg)。其中tr代表迹(trace)是方阵对角线元素之和，满足性质：对尺寸相同的矩阵A,B，![[公式]](assets/1620480603-5707bbfdd4eac92acdb6ef87d90cfc54.svg)，即![[公式]](assets/1620480603-c7bdf9fdbd0e7d13fbeabde56a144ba5.svg)是矩阵A,B的**内积**。与梯度相似，这里第一个等号是全微分公式，第二个等号表达了矩阵导数与微分的联系：全微分![[公式]](assets/1620480603-1b8b80a92f47373ed7a9bcd1bbd0cd31.svg)是导数![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)(m×n)与微分矩阵![[公式]](assets/1620480603-0d5db8357611a81e06132e92698cc5f0.svg)(m×n)的内积。

  

然后来建立运算法则。回想遇到较复杂的一元函数如![[公式]](assets/1620480603-95fe8aa706575ebc06b297c341cef0eb.svg)，我们是如何求导的呢？通常不是从定义开始求极限，而是先建立了初等函数求导和四则运算、复合等法则，再来运用这些法则。故而，我们来创立常用的矩阵微分的运算法则：

1.  加减法：![[公式]](assets/1620480603-b9260312759ec84fa1f8bdd111b03c29.svg)；矩阵乘法：![[公式]](assets/1620480603-04adc71d0f5fb26a36e9a181e6799edd.svg)；转置：![[公式]](assets/1620480603-633952a16c36aa6b6a008f8134e733c1.svg)；迹：![[公式]](assets/1620480603-5920fca232c52598859ec72437d249b6.svg)。
2.  逆：![[公式]](assets/1620480603-d2c3abe099851d221d7b2a6638b6fbfd.svg)。此式可在![[公式]](assets/1620480603-8831a7b12c9a536c79bd9be2605bcb9a.svg)两侧求微分来证明。
3.  行列式：![[公式]](assets/1620480603-f068ac4683c7f5db4e5e1c598dfe3225.svg)，其中![[公式]](assets/1620480603-3e34936e1c69a49c66947c3c4e7799f8.svg)表示X的伴随矩阵，在X可逆时又可以写作![[公式]](assets/1620480603-873fea888c7d9c5f310f907387ded586.svg)。此式可用Laplace展开来证明，详见张贤达《矩阵分析与应用》第279页。
4.  逐元素乘法：![[公式]](assets/1620480603-c6ad3f838bc379247d75baf4da419067.svg)，![[公式]](assets/1620480603-e5fcf115ac3201f6050783f26d5c9670.svg)表示尺寸相同的矩阵X,Y逐元素相乘。
5.  逐元素函数：![[公式]](assets/1620480603-afa6bceaf35c1d7c9dd2b2ea420d8097.svg)，![[公式]](assets/1620480603-d8033fa4593447d0169d0aa549c2335f.svg)是逐元素标量函数运算， ![[公式]](assets/1620480603-df75dffb3ca13ed6bce1df8467e7bc59.svg)是逐元素求导数。例如![[公式]](assets/1620480603-e109c2a80eb65920730c082d902355d0.svg)。

  

我们试图利用矩阵导数与微分的联系![[公式]](assets/1620480603-718322653ce326a5022089c13233c08d.svg)，在求出左侧的微分![[公式]](assets/1620480603-1b8b80a92f47373ed7a9bcd1bbd0cd31.svg)后，该如何写成右侧的形式并得到导数呢？这需要一些迹技巧(trace trick)：

1.  标量套上迹：![[公式]](assets/1620480603-ee81d386c867989cf34c5b60fd42ae4a.svg)
2.  转置：![[公式]](assets/1620480603-903ea8ac8ab175e4acae479cae063290.svg)。
3.  线性：![[公式]](assets/1620480603-a9c4b120fc8115b931184c25d03e9f8a.svg)。
4.  矩阵乘法交换：![[公式]](assets/1620480603-a4720e64f565fdc0952b2200f44b6383.svg)，其中![[公式]](assets/1620480603-a86f8657535c007558ea628b4b5b9c7a.svg)与![[公式]](assets/1620480603-52864ca07c63a1993198dc7c7f36e91e.svg)尺寸相同。两侧都等于![[公式]](assets/1620480603-88dfc29ba8c1427aae8e16d444188195.svg)。
5.  矩阵乘法/逐元素乘法交换：![[公式]](assets/1620480603-9b1cb4f1a9bb3722c48c00ca6e9c4dae.svg)，其中![[公式]](assets/1620480603-a953c127ce2ef9238dee3d67b419cf6a.svg)尺寸相同。两侧都等于![[公式]](assets/1620480603-e9d64b15da12259c9c012803dd57f406.svg)。

  

观察一下可以断言，**若标量函数f是矩阵X经加减乘法、逆、行列式、逐元素函数等运算构成，则使用相应的运算法则对f求微分，再使用迹技巧给df套上迹并将其它项交换至dX左侧，对照导数与微分的联系**![[公式]](assets/1620480603-718322653ce326a5022089c13233c08d.svg)**，即能得到导数。**

**特别地，若矩阵退化为向量，对照导数与微分的联系**![[公式]](assets/1620480603-4f5b39c0d80f35801319b00fe06b2154.svg)**，即能得到导数。**

  

在建立法则的最后，来谈一谈复合：假设已求得![[公式]](assets/1620480603-5fd226a30a4b6f532b23b80dd084ec4b.svg)，而Y是X的函数，如何求![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)呢？在微积分中有标量求导的链式法则![[公式]](assets/1620480603-ddb85bea23e1f98a7af333ea22a4db5a.svg)，但这里我们**不能随意沿用标量的链式法则**，因为矩阵对矩阵的导数![[公式]](assets/1620480603-719e189ddc28e9d41ccd34c1cee7d931.svg)截至目前仍是未定义的。于是我们继续追本溯源，链式法则是从何而来？源头仍然是微分。我们直接从微分入手建立复合法则：先写出![[公式]](assets/1620480603-4c2395a8d15c0b04a0edf5b246617166.svg)，再将dY用dX表示出来代入，并使用迹技巧将其他项交换至dX左侧，即可得到![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)。

最常见的情形是![[公式]](assets/1620480603-17a22fdc743e5e538a4a06ecc67b010a.svg)，此时 ![[公式]](assets/1620480603-5c90fd7e102ac58b37ef8bac788b5bf6.svg) ，可得到![[公式]](assets/1620480603-75b075706819bd5af6c0dadd88b3c635.svg)。注意这里![[公式]](assets/1620480603-45c813b5c5cdcb5c0575c6fa699751de.svg)，由于![[公式]](assets/1620480603-2f3478b1f1dcf04b1a3e68904a87623b.svg)是常量，![[公式]](assets/1620480603-1ad27e72a3b7f17204f5ff4df4534627.svg)，以及我们使用矩阵乘法交换的迹技巧交换了![[公式]](assets/1620480603-151d1895ecc560f660cdb1fde601024b.svg)与![[公式]](assets/1620480603-24500c30f1c598e72490259b989fae10.svg)。

  

接下来演示一些算例。特别提醒要依据已经建立的运算法则来计算，不能随意套用微积分中标量导数的结论，比如认为AX对X的导数为A，这是没有根据、意义不明的。

例1：![[公式]](assets/1620480603-f5414c5434c8e6f7e4af9b885c0876a1.svg)，求![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)。其中![[公式]](assets/1620480603-b641a73fe82f90c3ab3ccc28386c606d.svg)是![[公式]](assets/1620480603-e0f8668264115ddd23b342e9ecf00029.svg)列向量，![[公式]](assets/1620480603-6ce37be68c2df90fbb8ad8fe13a3f033.svg)是![[公式]](assets/1620480603-efded31b5fda68c35f6e2c4d41408a99.svg)矩阵，![[公式]](assets/1620480603-2cce75eb5bce235e239bea93fe1f9cea.svg)是![[公式]](assets/1620480603-4b92dee5c11cc1784e9d2822857f1f4d.svg)列向量，![[公式]](assets/1620480603-b1546fe57556d315e29ee6712725da66.svg)是标量。

解：先使用矩阵乘法法则求微分，![[公式]](assets/1620480603-b318c8478c46453aade17b31e3faa45c.svg)，注意这里的![[公式]](assets/1620480603-9ed7b1babb486dfcf45a865e2383377e.svg)是常量，![[公式]](assets/1620480603-70af4eb99650183ea6cba45d4c2ca273.svg)。由于df是标量，它的迹等于自身，![[公式]](assets/1620480603-757066247e2e353ea98ae0310e3dae5d.svg)，套上迹并做矩阵乘法交换：![[公式]](assets/1620480603-5714d4fa3ffecbad00dba1c6ee0146f1.svg)，注意这里我们根据![[公式]](assets/1620480603-a4720e64f565fdc0952b2200f44b6383.svg)交换了![[公式]](assets/1620480603-890bdba3bd86220265605a7c38aaa1f6.svg)与![[公式]](assets/1620480603-2cce75eb5bce235e239bea93fe1f9cea.svg)。对照导数与微分的联系![[公式]](assets/1620480603-1dbd884bd9635d2770dc3ac7498bed70.svg)，得到![[公式]](assets/1620480603-629f623b111126a6c930f31ff5c45c69.svg)。

注意：这里不能用![[公式]](assets/1620480603-19aab370630cc5f6dcbbe566800045db.svg)，导数与矩阵乘法的交换是不合法则的运算（而微分是合法的）。有些资料在计算矩阵导数时，会略过求微分这一步，这是逻辑上解释不通的。

  

例2：![[公式]](assets/1620480603-56b021881d21cefaeadb366a7567607f.svg)，求![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)。其中![[公式]](assets/1620480603-b641a73fe82f90c3ab3ccc28386c606d.svg)是![[公式]](assets/1620480603-e0f8668264115ddd23b342e9ecf00029.svg)列向量，![[公式]](assets/1620480603-6ce37be68c2df90fbb8ad8fe13a3f033.svg)是![[公式]](assets/1620480603-efded31b5fda68c35f6e2c4d41408a99.svg)矩阵，![[公式]](assets/1620480603-2cce75eb5bce235e239bea93fe1f9cea.svg)是![[公式]](assets/1620480603-4b92dee5c11cc1784e9d2822857f1f4d.svg)列向量，exp表示逐元素求指数，![[公式]](assets/1620480603-b1546fe57556d315e29ee6712725da66.svg)是标量。

解：先使用矩阵乘法、逐元素函数法则求微分：![[公式]](assets/1620480603-66e4aa73b3c8c6dd2077138f7a80febc.svg)，再套上迹并做交换：![[公式]](assets/1620480603-abdb4e5790712bf6d2964478cd52092c.svg)![[公式]](assets/1620480603-6352a2815792cc2c3ebc08f1408ba956.svg)，注意这里我们先根据![[公式]](assets/1620480603-9b1cb4f1a9bb3722c48c00ca6e9c4dae.svg)交换了![[公式]](assets/1620480603-b641a73fe82f90c3ab3ccc28386c606d.svg)、![[公式]](assets/1620480603-9b3262a297444c716a5b3947e61745f5.svg)与![[公式]](assets/1620480603-af82b9aeab948b5fee0f20fd6a9adc1e.svg)，再根据![[公式]](assets/1620480603-a4720e64f565fdc0952b2200f44b6383.svg)交换了![[公式]](assets/1620480603-74c962f58efc2b69653cad89b10c2a5b.svg)与![[公式]](assets/1620480603-2cce75eb5bce235e239bea93fe1f9cea.svg)。对照导数与微分的联系![[公式]](assets/1620480603-1dbd884bd9635d2770dc3ac7498bed70.svg)，得到![[公式]](assets/1620480603-bcc61e6588f063bfa692bd87e10077cd.svg)。

  

例3：![[公式]](assets/1620480603-72e52aa6d9fb237351d2c92d91ddb82a.svg)，求![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)。其中![[公式]](assets/1620480603-2a437219c241ce5bc116bd50c17713d3.svg)是![[公式]](assets/1620480603-7249c74d7c03e4f11d3b0f3fe14c32b0.svg)矩阵，![[公式]](assets/1620480603-6ce37be68c2df90fbb8ad8fe13a3f033.svg)是![[公式]](assets/1620480603-efded31b5fda68c35f6e2c4d41408a99.svg)矩阵，![[公式]](assets/1620480603-ce020eb98bb704a4d4bd27920c72fe8b.svg)是![[公式]](assets/1620480603-fa1fb5bd7b377990318a6629f270c9b4.svg)矩阵，![[公式]](assets/1620480603-4d1c242aafb8be1182c1b6561b484b64.svg)是![[公式]](assets/1620480603-c8785b50e5a60eed1a284b953a2b6444.svg)对称矩阵，![[公式]](assets/1620480603-4c9c7306fda5b3372712b2c916456bb3.svg)是逐元素函数，![[公式]](assets/1620480603-b1546fe57556d315e29ee6712725da66.svg)是标量。

解：先求![[公式]](assets/1620480603-5fd226a30a4b6f532b23b80dd084ec4b.svg)，求微分，使用矩阵乘法、转置法则：![[公式]](assets/1620480603-91df14680b28d74062d4471ed3995ff6.svg)，对照导数与微分的联系，得到![[公式]](assets/1620480603-fa8a28a11b47944382dcbf8631d49e83.svg)，注意这里M是对称矩阵。为求![[公式]](assets/1620480603-fe6ea7be6eb9c415d7b6b66beb5f00ef.svg)，写出![[公式]](assets/1620480603-4c2395a8d15c0b04a0edf5b246617166.svg)，再将dY用dX表示出来代入，并使用矩阵乘法/逐元素乘法交换：![[公式]](assets/1620480603-949fbe0c9ae57b49a0c6b114c7c18aa5.svg)，对照导数与微分的联系，得到![[公式]](assets/1620480603-d06bef254b4ab06e3940b056cf7b45b6.svg)。

  

例4【线性回归】：![[公式]](assets/1620480603-806f80e70641bb7d9b814100c65f290b.svg)， 求![[公式]](assets/1620480603-862a124e766414bbb92b51708f107da5.svg)的最小二乘估计，即求![[公式]](assets/1620480603-a91b2a422ef7b169ddde1c172657dac5.svg)的零点。其中![[公式]](assets/1620480603-95f3155226c64dbe93966df4e18d3692.svg)是![[公式]](assets/1620480603-e0f8668264115ddd23b342e9ecf00029.svg)列向量，![[公式]](assets/1620480603-6ce37be68c2df90fbb8ad8fe13a3f033.svg)是![[公式]](assets/1620480603-efded31b5fda68c35f6e2c4d41408a99.svg)矩阵，![[公式]](assets/1620480603-862a124e766414bbb92b51708f107da5.svg)是![[公式]](assets/1620480603-4b92dee5c11cc1784e9d2822857f1f4d.svg)列向量，![[公式]](assets/1620480603-f32f9aac32d40c08bf41372d319a306a.svg)是标量。

解：这是标量对向量的导数，不过可以把向量看做矩阵的特例。先将向量模平方改写成向量与自身的内积：![[公式]](assets/1620480603-3298bd81ec632fa644b0d90977790d50.svg)，求微分，使用矩阵乘法、转置等法则：![[公式]](assets/1620480603-4698d58456768ddecd4502a2ab83a8a0.svg)，注意这里![[公式]](assets/1620480603-5d0333f35b2913e543ae2656a4fad0f6.svg)和![[公式]](assets/1620480603-0dfce241983a096d5192fc3347652a9f.svg)是向量，两个向量的内积满足![[公式]](assets/1620480603-ac5e495cce14b143a7fea476e41b4377.svg)。对照导数与微分的联系![[公式]](assets/1620480603-fcb33a5fc0e2ec68a3239d6e5ec4ca0d.svg)，得到![[公式]](assets/1620480603-f16804cc01ad0f2d81bbab1dffd68768.svg)。![[公式]](assets/1620480603-77be76312209bcceff98fd8307e2a89f.svg)即![[公式]](assets/1620480603-c6802907f6e1df8518d0b71559e82cd6.svg)，得到![[公式]](assets/1620480603-862a124e766414bbb92b51708f107da5.svg)的最小二乘估计为![[公式]](assets/1620480603-4af6a0fe497ec220a0caa40684ed0585.svg)。

  

例5【方差的最大似然估计】：样本![[公式]](assets/1620480603-095cf9aab2d603f292beda4d70f49557.svg)，求方差![[公式]](assets/1620480603-c982247bd9520824a5e12834c5741b9b.svg)的最大似然估计。写成数学式是：![[公式]](assets/1620480603-f9ec8c07f69c95b9624c001c8281d906.svg)，求![[公式]](assets/1620480603-229fb8c8baef87d65929ab9a5b7969a3.svg)的零点。其中![[公式]](assets/1620480603-d09874df3fb1e81462501877929cf703.svg)是![[公式]](assets/1620480603-5a465dbd636185ae5e3cb08f5348f82c.svg)列向量，![[公式]](assets/1620480603-b0c05e7d97a45acc6b773e9ac7c5cf1d.svg)是样本均值，![[公式]](assets/1620480603-c982247bd9520824a5e12834c5741b9b.svg)是![[公式]](assets/1620480603-f41e184686a1165cad0497e845427e8a.svg)对称正定矩阵，![[公式]](assets/1620480603-f32f9aac32d40c08bf41372d319a306a.svg)是标量，log表示自然对数。

解：首先求微分，使用矩阵乘法、行列式、逆等运算法则，第一项是![[公式]](assets/1620480603-7f38e19db60fb4519e6d16f2f9e2d605.svg)，第二项是![[公式]](assets/1620480603-d68b1868b2fb4d19b7e62cd4049efdd6.svg)。再给第二项套上迹做交换：![[公式]](assets/1620480603-6594cdc4e6cb6d55103f4c13da5c01f4.svg)![[公式]](assets/1620480603-6c857e46172c5f43719ab48628b721f7.svg)![[公式]](assets/1620480603-d76368ec43a0f9fda15c47fbaa6f0964.svg)，其中先交换迹与求和，然后将 ![[公式]](assets/1620480603-b3ec4949d331e9562ced00f25148b5c0.svg)交换到左边，最后再交换迹与求和，并定义![[公式]](assets/1620480603-9a687a466db991836aa6f719094fdd26.svg)为样本方差矩阵。得到![[公式]](assets/1620480603-d6e789a90cd63c4e24de6cc4ccf1ccc3.svg)。对照导数与微分的联系，有![[公式]](assets/1620480603-ce0a6dbed8cb25fb33e85bb8e34776e9.svg)，其零点即![[公式]](assets/1620480603-c982247bd9520824a5e12834c5741b9b.svg)的最大似然估计为![[公式]](assets/1620480603-39e34d04e10d1c45e5ac7cefcdc83246.svg)。

  

例6【多元logistic回归】：![[公式]](assets/1620480603-29efff5a0f149366fc86b59cf72ce2f8.svg)，求![[公式]](assets/1620480603-7129e2cc15b34c14452a93b460e4b0d7.svg)。其中![[公式]](assets/1620480603-95f3155226c64dbe93966df4e18d3692.svg)是除一个元素为1外其它元素为0的![[公式]](assets/1620480603-e0f8668264115ddd23b342e9ecf00029.svg)列向量，![[公式]](assets/1620480603-2a437219c241ce5bc116bd50c17713d3.svg)是![[公式]](assets/1620480603-efded31b5fda68c35f6e2c4d41408a99.svg)矩阵，![[公式]](assets/1620480603-878735fee9916dce1437274caeb8a5c1.svg)是![[公式]](assets/1620480603-4b92dee5c11cc1784e9d2822857f1f4d.svg)列向量，![[公式]](assets/1620480603-f32f9aac32d40c08bf41372d319a306a.svg)是标量；log表示自然对数，![[公式]](assets/1620480603-2ef2300747d2b9a22e4036d3c6dfb6fc.svg)，其中![[公式]](assets/1620480603-e334b2d1324feb753d4dccd18f1e9eae.svg)表示逐元素求指数，![[公式]](assets/1620480603-a882e17b38c0fab7ad212beafa7817d6.svg)代表全1向量。

解1：首先将softmax函数代入并写成![[公式]](assets/1620480603-b91afb551f204bb15c764076136b4757.svg)，这里要注意逐元素log满足等式![[公式]](assets/1620480603-f7756a0b424c3b9b91a2517425ecb7eb.svg)，以及![[公式]](assets/1620480603-95f3155226c64dbe93966df4e18d3692.svg)满足![[公式]](assets/1620480603-b9688cfc29ed8a376d8c49b913c5964e.svg)。求微分，使用矩阵乘法、逐元素函数等法则：![[公式]](assets/1620480603-86c87871cb338c43792faeb9bf506e80.svg)。再套上迹并做交换，注意可化简![[公式]](assets/1620480603-2a93bebb4b600426e3a682177ef23229.svg)，这是根据等式![[公式]](assets/1620480603-e269f082d708c5f5272a01b4f72dc653.svg)，故![[公式]](assets/1620480603-50c1d07fa1da9bdb8f961bec34f34341.svg)。对照导数与微分的联系，得到![[公式]](assets/1620480603-80d07343bbe3435fc7ffdd8350964361.svg)。

解2：定义![[公式]](assets/1620480603-ff18e0ade570b748e1ad1c12bc601fa1.svg)，则![[公式]](assets/1620480603-aac30443c743bfc21d3e35ce0b0081b4.svg)，先同上求出![[公式]](assets/1620480603-e86f8213b45340da44a7047b016f1cd1.svg)，再利用复合法则：![[公式]](assets/1620480603-13968a4db8787e9dc25b81fbde389feb.svg)，得到![[公式]](assets/1620480603-7efc7b75187c426aea2d55f92c1f0916.svg)。

  

最后一例留给经典的神经网络。神经网络的求导术是学术史上的重要成果，还有个专门的名字叫做BP算法，我相信如今很多人在初次推导BP算法时也会颇费一番脑筋，事实上使用矩阵求导术来推导并不复杂。为简化起见，我们推导二层神经网络的BP算法。

例7【二层神经网络】：![[公式]](assets/1620480603-4281a73dbc2dbcdb0ad9dc295211d089.svg)，求![[公式]](assets/1620480603-5f18570dcc369135666b7587f9ad7c46.svg)和![[公式]](assets/1620480603-d722fef727d76f3e564551fdc5f7a347.svg)。其中![[公式]](assets/1620480603-95f3155226c64dbe93966df4e18d3692.svg)是除一个元素为1外其它元素为0的的![[公式]](assets/1620480603-e0f8668264115ddd23b342e9ecf00029.svg)列向量，![[公式]](assets/1620480603-027a1fcff2639fba7abfc4e80789d64e.svg)是![[公式]](assets/1620480603-7d26c4e242e8116cf3b5340dc921c900.svg)矩阵，![[公式]](assets/1620480603-71afb8d599a82c4b886ee5009faa677d.svg)是![[公式]](assets/1620480603-bf74d7d9ef7f89f43a295cfe5e7061ff.svg)矩阵，![[公式]](assets/1620480603-878735fee9916dce1437274caeb8a5c1.svg)是![[公式]](assets/1620480603-4b92dee5c11cc1784e9d2822857f1f4d.svg)列向量，![[公式]](assets/1620480603-f32f9aac32d40c08bf41372d319a306a.svg)是标量；log表示自然对数，![[公式]](assets/1620480603-2ef2300747d2b9a22e4036d3c6dfb6fc.svg)同上，![[公式]](assets/1620480603-4c9c7306fda5b3372712b2c916456bb3.svg)是逐元素sigmoid函数![[公式]](assets/1620480603-5f19367f5078e37e6213fbf769c8a176.svg)。

解：定义![[公式]](assets/1620480603-e7f3033a9437c91a1b19bdf91103ba6e.svg)，![[公式]](assets/1620480603-3d5eb63cd19bba34f88293a3060a1559.svg)，![[公式]](assets/1620480603-375c3ae48b72ec38e848830be5329cc5.svg)，则![[公式]](assets/1620480603-a26cdc1c6eb4a66a1a5db81891b70e6e.svg)。在前例中已求出![[公式]](assets/1620480603-bdde3006062c94863912f64d19ff1cbf.svg)。使用复合法则，![[公式]](assets/1620480603-b3d5f181033eb6eb9c58f22cc4dae7e5.svg)，使用矩阵乘法交换的迹技巧从第一项得到![[公式]](assets/1620480603-ae037da75e27ff40ec0fea40caaaf782.svg)，从第二项得到![[公式]](assets/1620480603-325a547ee71fab162b7949113ee9ca62.svg)。接下来对第二项继续使用复合法则来求![[公式]](assets/1620480603-d8000c27bb5f6666e692fcf713b4d4f9.svg)，并利用矩阵乘法和逐元素乘法交换的迹技巧：![[公式]](assets/1620480603-815b5920b5f12e4caca3fbaf24f817f7.svg)，得到![[公式]](assets/1620480603-2a84ca160ac9cf8c956742802ef38802.svg)。为求![[公式]](assets/1620480603-5f18570dcc369135666b7587f9ad7c46.svg)，再用一次复合法则：![[公式]](assets/1620480603-3de1d6d6717012e399cb83e37f35510f.svg)，得到![[公式]](assets/1620480603-b17a26d603ea3c2e13fd2911551b1d2f.svg)。

推广：样本![[公式]](assets/1620480603-57f020cea067d2735fd2200328f73e74.svg)，![[公式]](assets/1620480603-431d2eefc2e9562dc9d955d5b086b2fe.svg)，其中![[公式]](assets/1620480603-76ab0b649cdc2aefac29add843a4bd96.svg)是![[公式]](assets/1620480603-50dc62d5b782b929638090441a94d6ae.svg)列向量，![[公式]](assets/1620480603-23efdeb1d68cdb9b7bfa15c24bb6559e.svg)是![[公式]](assets/1620480603-5a465dbd636185ae5e3cb08f5348f82c.svg)列向量，其余定义同上。

解1：定义![[公式]](assets/1620480603-46d84cce5f3758a7f5f7ec47b5a05479.svg)，![[公式]](assets/1620480603-84a93a639beff1147e21aa5bbe3bb953.svg)，![[公式]](assets/1620480603-390785a868d770b4ba654d11a5fafc45.svg)，则![[公式]](assets/1620480603-3645a72e511845818e42ef6296f13e0a.svg)。先同上可求出![[公式]](assets/1620480603-8c2f6e96112f72327596b7a9b6e6d2cf.svg)。使用复合法则，![[公式]](assets/1620480603-87329d949020d4436fb8417266e545cc.svg)，从第一项得到得到![[公式]](assets/1620480603-9a5d61a4cbecc9422723ac7cb57cf78c.svg)，从第二项得到![[公式]](assets/1620480603-eb584a7799c78761b04db35bc74e0a1f.svg)，从第三项得到到![[公式]](assets/1620480603-2f507c01023d15e6d5e7e70ab374b6b7.svg)。接下来对第二项继续使用复合法则，得到![[公式]](assets/1620480603-33e94944aea8243d64fb6de45d9cce89.svg)。为求![[公式]](assets/1620480603-83417f898edf03806e90707fef533754.svg)，再用一次复合法则：![[公式]](assets/1620480603-c8e2cd9d9d8a3b0739c62d219dfdf0f4.svg)，得到![[公式]](assets/1620480603-87335a57ef14de9d3ddfee674fe9680d.svg)，![[公式]](assets/1620480603-fdfeeada0602dd4840978e242b1c3ffe.svg)。

解2：可以用矩阵来表示N个样本，以简化形式。定义![[公式]](assets/1620480603-b702877b6fa2079ebd3d93ff0165bc18.svg)，![[公式]](assets/1620480603-54d4ea6ffb9f5ec2d7fe8e2ca5864540.svg)，![[公式]](assets/1620480603-d580fd65a9c94e0a1a8eadaa98e89ecf.svg)，![[公式]](assets/1620480603-0e507bd5c607fda8d96e8c1ad6fa7990.svg)，注意这里使用全1向量来扩展维度。先同上求出![[公式]](assets/1620480603-8572329a1a4f87c106eb84cf32f5358a.svg)。使用复合法则，![[公式]](assets/1620480603-928a3a829bbab3291fdbc26978fed658.svg) ，从第一项得到![[公式]](assets/1620480603-2af6690a0132b78c86504b3c57baadf8.svg)，从第二项得到![[公式]](assets/1620480603-20687c3fb9101ce638a73ba5f0ce2ccb.svg)，从第三项得到到![[公式]](assets/1620480603-c80c3cdc42af75eb0385419f31168bef.svg)。接下来对第二项继续使用复合法则，得到![[公式]](assets/1620480603-15e7e5e5fff55632b5ecaa92670edc08.svg)。为求![[公式]](assets/1620480603-83417f898edf03806e90707fef533754.svg)，再用一次复合法则：![[公式]](assets/1620480603-5ac734f22680996b54dabb591f389aac.svg)，得到![[公式]](assets/1620480603-807573f3d046165fcca7b7fdd36ac1f0.svg)，![[公式]](assets/1620480603-3bd31e6f553699553a7395b2455abbd6.svg)。

  

下篇见[https://zhuanlan.zhihu.com/p/24863977](https://zhuanlan.zhihu.com/p/24863977)。