---
title: java_learn
categories:
  - 总结
description: <read more ...>
mathjax: true
permalink_defaults: 'category/:title/'
date: 2021-04-25 19:52:00
urlname:
tags:



---

# 基础概念

## .debug

- 如何加断点

  - 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可

- 如何运行加了断点的程序

  - 在代码区域右键Debug执行

- 看哪里

  - 看Debugger窗口

  - 看Console窗口

- 点哪里

  - 点Step Into (F7)这个箭头，也可以直接按F7

- 如何删除断点

  - 选择要删除的断点，单击鼠标左键即可

  - 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除



##   原码反码补码

1. 原码

   ​	计算机保存最原始的数字，也是没有正和负的数字，叫没符号数字

   ​	左边第一位腾出位置，存放符号，正用0来表示，负用1来表示

2. 反码

   ​	左边第一位腾出位置，存放符号，正用0来表示，负用1来表示

   ​	“反码”表示方式是用来处理负数的，符号位置不变，其余位置相反

   ​	![](java-learn/%E6%AD%A3%E5%8F%8D%E8%A1%A5%E7%A0%81.png)

3. 补码

   ​	解决两个0的问题

   ​	+1,舍弃掉最高位

   ​	![](java-learn/%E6%AD%A3%E5%8F%8D%E8%A1%A5%E7%A0%812.png)

##  位运算

​			亦或与非左右移

# 	方法

##  定义

~~~java
public static void method (    ) {
	// 方法体;
}
public static 返回值类型 方法名(参数) {
   方法体; 
   return 数据 ;
}
~~~

##  调用过程

​		总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。

~~~ java
方法名() 
~~~

##  方法重载

​		overload，同一类中，方法名相同。

##  参数传递

​		基本数据类型的参数，形式参数的改变，不影响实际参数 。

​		原因：每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失

​		对于引用类型的参数，形式参数的改变，影响实际参数的值 

​		引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 。

# 面向对象

简单理解：类就是对现实事物的一种描述，对象则为具体存在的事物

## 类的定义步骤：**

​	① 定义类

​	② 编写类的成员变量

​	③ 编写类的成员方法

~~~java
public class Student {
    // 属性 : 姓名, 年龄
    // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外
    String name;
    int age;

    // 行为 : 学习
    // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字.
    public void study(){
        System.out.println("学习");
    }
}
~~~

## 定义调用

* **创建对象的格式：**
  * 类名 对象名 = new 类名();
* **调用成员的格式：**
  * 对象名.成员变量
  * 对象名.成员方法()

## 对象内存

​			单个对象

​			![单个对象内存图](java-learn/%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.png)

​			多个对象

​			![多个对象内存图](java-learn/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.png)

<strong style="color:red;">多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</strong>

​			多个对象指向相同内存图

​			![引用对象内存](java-learn/%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98.png)

<strong style="color:red;">当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据</strong>

##  成员变量和局部变量

* **类中位置不同：**成员变量（类中方法外）局部变量（方法内部或方法声明上）
* **内存中位置不同：**成员变量（堆内存）局部变量（栈内存）
* **生命周期不同：**成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
* **初始化值不同：**成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）

## 封装

### private关键字

特点 :被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，	提供相应的操作

​		提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰

​		提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰

### this关键字

概述 : this修饰的变量用于指代成员变量，其主要作用是（<strong style="color:red;">区分局部变量和成员变量的重名问题</strong>）

* 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量
* 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量

## 构造方法

* **格式注意 :**
  *  方法名与类名相同，大小写也要一致
  *  没有返回值类型，连void都没有
  *  没有具体的返回值（不能由retrun带回结果数据）
* **执行时机 ：**
  * 创建对象的时候调用，每创建一次对象，就会执行一次构造方法
  * 不能手动调用构造方法
* **执行作用 ：**
  * 用于给对象的数据（属性）进行初始化
* 注意事项  ：
  * 构造方法的注意事项
  * 无论是否使用，都手动书写无参数构造方法，和带参数构造方法

# API

​			API (Application Programming Interface) ：应用程序编程接口

---

##  **如何使用API帮助文档 :** 

​			打开帮助文档

​			找到索引选项卡中的输入框

​			在输入框中输入Random

​			看类在哪个包下

​			看类的描述

​			看构造方法

‘			看成员方法

## 	**Scanner类 :**

​	next() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键

​	nextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符    

##  String类

​	 1 String 类在 java.lang 包下，所以使用的时候不需要导包

​	2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象

​	3 字符串不可变，它们的值在创建后不能被更改

### 构造方法区别

​	**通过构造方法创建**	通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

​	**直接赋值方式创建**	以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护

### 字符串比较， ==使用，equals

- == 比较基本数据类型：比较的是具体的值
- == 比较引用数据类型：比较的是对象地址值
- **String类 :  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写**

###    字符串截取

​		 public char[] toCharArray( )：

​		substring(0,3);

### 字符串替换

​		 String replace(CharSequence target, CharSequence replacement)

### 切割字符串

```java
String[] split(String regex) ：根据传入的字符串作为规则进行切割将切割后的内容存入字符串数组中，并将字符串数组返回
```
## StringBuilder类概述

**概述 :** StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的

---

### **常用的构造方法**

| 方法名                             | 说明                                       |
| :--------------------------------- | :----------------------------------------- |
| public StringBuilder()             | 创建一个空白可变字符串对象，不含有任何内容 |
| public StringBuilder(String   str) | 根据字符串的内容，来创建可变字符串对象     |

### StringBuilder常用的成员方法

**添加和反转方法**

| 方法名                                  | 说明                     |
| --------------------------------------- | ------------------------ |
| public StringBuilder   append(任意类型) | 添加数据，并返回对象本身 |
| public StringBuilder   reverse()        | 返回相反的字符序列       |

### StringBuilder和String相互转换

toString,构造方法

# 集合基础

## ArrayList

**集合和数组的区别 :** 

​	共同点：都是存储数据的容器

​	不同点：数组的容量是固定的，集合的容量是可变的



---

### 构造方法和添加方法

​	

| public ArrayList()                   | 创建一个空的集合对象               |
| ------------------------------------ | ---------------------------------- |
| public boolean add(E e)              | 将指定的元素追加到此集合的末尾     |
| public void add(int index,E element) | 在此集合中的指定位置插入指定的元素 |

**ArrayList<E> ：** 

​	可调整大小的数组实现 

​	<E> : 是一种特殊的数据类型，泛型。

### ArrayList类常用方法

| public boolean remove(Object o)   | 删除指定的元素，返回删除是否成功       |
| --------------------------------- | -------------------------------------- |
| public E remove(int index)        | 删除指定索引处的元素，返回被删除的元素 |
| public E set(int index,E element) | 修改指定索引处的元素，返回被修改的元素 |
| public E get(int index)           | 返回指定索引处的元素                   |
| public int size()                 | 返回集合中的元素的个数                 |

### 常见方法背诵记忆

​		增删改查翻转转换

# git

开发中要解决的问题

+ 代码备份
+ 版本控制
+ 协同工作
+ 责任追溯



---

## 本地添加

![](java-learn/31_Git%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

| 命令                     | 作用                                                   |
| ------------------------ | ------------------------------------------------------ |
| git init                 | 初始化，创建 git 仓库                                  |
| git status               | 查看 git 状态(缓存区) （文件是否进行了添加、提交操作） |
| git add 文件名           | 添加，将指定文件添加到暂存区                           |
| git commit -m '提交信息' | 提交，将暂存区文件提交到历史仓库                       |
| git log                  | 查看日志（ git 提交的历史日志）                        |

## 本地版本管理

+ 准备动作

  1. 查看 my_project 的 log 日志
     git reflog ：可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作）
  2. 增加一次新的修改记录

+ 需求: 将代码切换到第二次修改的版本

  指令：git reset --hard 版本唯一索引值

## 分支管理操作

+ 创建和切换

  创建命令：git branch 分支名
  切换命令：git checkout 分支名

+ 新分支添加文件

  查看文件命令：ls

  总结：不同分支之间的关系是平行的关系，不会相互影响

  即一个分支的操作另一个不受影响

+ 合并分支

  合并命令：git merge 分支名

+ 删除分支

  删除命令：git branch -d 分支名

+ 查看分支列表

  查看命令：git branch

## 先有本地项目,远程为空(应用)

​		 步骤

1. 创建本地仓库

2. 创建或修改文件，添加（add）文件到暂存区，提交（commit）到本地仓库

3. 创建远程仓库

4. 推送到远程仓库

   git remote add 远程名称 远程仓库URL
   git push -u 仓库名称 分支名

## 先有远程仓库,本地为空

1. 将远程仓库的代码，克隆到本地仓库
   克隆命令：git clone 仓库地址
2. 创建新文件，添加并提交到本地仓库
3. 推送至远程仓库
4. 项目拉取更新
   拉取命令：git pull 远程仓库名 分支名

## 代码冲突(应用)

​			情景一：在当前分支上，直接修改冲突代码--->add--->commit。

​			情景二：在本地当前分支上，修改冲突代码--->add--->commit--->push

​			都是通过cat命令查看冲突部分。

​			cat查看冲突文件

# **6.IDEA集成Git**

## **IDEA中配置Git(应用)**

​		1\. File -\> Settings

![](java-learn/64_IDEA%E4%B8%AD%E9%85%8D%E7%BD%AEGit.png)

2. Version Control -\> Git -\>

指定git.exe存放目录

3\. 点击Test测试

![](java-learn/65_IDEA%E4%B8%AD%E9%85%8D%E7%BD%AEGit.png)

**创建本地仓库(应用)**

>   1\. VCS-\>Import into Version Control-\>Create Git Repository

>   2\. 选择工程所在的目录,这样就创建好本地仓库了

>   3\. 点击git后边的对勾,将当前项目代码提交到本地仓库

>   注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可

![](java-learn/67_%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png)

## **版本切换(应用)**

>   方式一: 控制台Version Control-\>Log-\>Reset Current Branch...-\>Reset

>   这种切换的特点是会抛弃原来的提交记录

>   方式二:控制台Version Control-\>Log-\>Revert
>   Commit-\>Merge-\>处理代码-\>commit

>   这种切换的特点是会当成一个新的提交记录,之前的提交记录也都保留

![](java-learn/70_%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2.png)

## **分支管理(应用)**

>   创建分支

>   VCS-\>Git-\>Branches-\>New Branch-\>给分支起名字-\>ok

![](java-learn/74_%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF.png)

切换分支

idea右下角Git-\>选择要切换的分支-\>checkout

合并分支

VCS-\>Git-\>Merge changes-\>选择要合并的分支-\>merge

![](java-learn/76_%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF.png)

处理分支中的代码

![](java-learn/78_%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF.png)

删除分支

idea右下角-\>选中要删除的分支-\>Delete

![](java-learn/80_%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF.png)

## **本地仓库推送到远程仓库(应用)**

>   1\. VCS-\>Git-\>Push-\>点击master Deﬁne remote

>   2\. 将远程仓库的路径复制过来-\>Push

![](java-learn/81_%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png)

## **远程仓库克隆到本地仓库(应用)**

File->Close Project->Checkout from Version Control->Git->指定远程仓库的路径->指定本地存放的路径->clone

![](java-learn/83_%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png)