---
title: cnn发展综述
categories:
  - 论文
  - 综合
description: <read more ...>
mathjax: true
permalink_defaults: 'category/:title/'
date: 2021-07-10 16:22:23
urlname:
tags:
---

# LeNet5

论文：http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf

LeNet-5：是Yann LeCun在1998年设计的用于手写数字识别的卷积神经网络，当年美国大多数银行就是用它来识别支票上面的手写数字的，它是早期卷积神经网络中最有代表性的实验系统之一。

LenNet-5共有7层（不包括输入层），每层都包含不同数量的训练参数，如下图所示。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-6fa3eace4edc40f5e8fe801f269697c1.png)

LeNet-5中主要有2个卷积层、2个下抽样层（池化层）、3个全连接层3种连接方式

**LeNet-5的训练算法**   
训练算法与传统的BP算法差不多。主要包括4步，这4步被分为两个阶段：   
第一阶段，向前传播阶段：   
a）从样本集中取一个样本(X,Yp)，将X输入网络；   
b）计算相应的实际输出Op。   
在此阶段，信息从输入层经过逐级的变换，传送到输出 层。这个过程也是网络在完成训练后正常运行时执行的过程。在此过程中，网络执行的是计算（实际上就是输入与每层的权值矩阵相点乘，得到最后的输出结果）：   
Op=Fn（…（F2（F1（XpW（1））W（2））…）W（n））   
第二阶段，向后传播阶段   
a）算实际输出Op与相应的理想输出Yp的差；   
b）按极小化误差的方法反向传播调整权矩阵。

**卷积神经网络的优点**   
卷积网络较一般神经网络在图像处理方面有 如下优点   
a）输入图像和网络的拓扑结构能很好的吻合；   
b）特征提取和模式分类同时进行，并同时在训练中产生；   
c）权重共享可以减少网络的训练参数，使神经网络结构变得更简单，适应性更强。   
		**总结**   
卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式。

通过对LeNet-5的网络结构的分析，可以直观地了解一个卷积神经网络的构建方法，可以为分析、构建更复杂、更多层的卷积神经网络做准备。

**LaNet-5的局限性**   
CNN能够得出原始图像的有效表征，这使得CNN能够直接从原始像素中，经过极少的预处理，识别视觉上面的规律。**然而，由于当时缺乏大规模训练数据，计算机的计算能力也跟不上，LeNet-5 对于复杂问题的处理结果并不理想**。

# AlexNet

论文：http://vision.stanford.edu/teaching/cs231b_spring1415/slides/alexnet_tugce_kyunghee.pdf

AlexNet于2012年由Alex Krizhevsky, Ilya Sutskever 和 Geoffrey Hinton等人提出，并在2012 ILSVRC (ImageNet Large-Scale Visual Recognition Challenge)中取得了最佳的成绩。这也是第一次CNN取得这么好的成绩，并且把第二名远远地甩在了后面，因此震惊了整个领域，从此CNNs才开始被大众所熟知。

这里简单地说一下这个ILSVRC，它是一个ImageNet发起的挑战，是计算机视觉领域的奥运会。全世界的团队带着他们的模型来对ImageNet中的数以千万的共1000个类别的图片进行分类、定位、识别。这个是一个相当有难度的工作，1000个类别啊。

那我们来看看这个AlexNet的结构把：

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-82257b1108c8a5d318340a01c68170de.png)

输入的图片是256×256，然后进行随机的裁剪得到227×227大小，然后输入进网络中。可见，这个输入比LeNet的要大得多，这种大小，在当年已经是图片的主流大小了。

关于AlexNet有如下要点：

1、在ImageNet数据上对网络进行了培训，该数据包含来自22,000多个类别的超过1500万个带注释的图像。

2、使用ReLU进行非线性函数（发现减少训练时间，因为ReLU比传统的tanh函数快几倍）。

3、使用的数据增强技术包括图像转换，水平反射和补丁提取。

4、实施了dropout层，以解决过度拟合训练数据的问题。

5、使用mini-batch SGD训练模型，具有动量和重量衰减的特定值。

6、在两个GTX 580 GPU上训练五到六天。

7、每一层权重均初始化为0均值0.01标准差的高斯分布，在第二层、第四层和第五层卷积的偏置被设置为1.0，而其他层的则为0，目的是为了加速早期学习的速率（因为激活函数是ReLU，1.0的偏置可以让大部分输出为正）。

8、学习速率初始值为0.01，在训练结束前共减小3次，每次减小都出现在错误率停止减少的时候，每次减小都是把学习速率除以10 。

9、局部响应归一化。在使用饱和型的激活函数时，通常需要对输入进行归一化处理，以利用激活函数在0附近的线性特性与非线性特性，并避免饱和，但对于ReLU函数，不需要输入归一化。然而，Alex等人发现通过LRN这种归一化方式可以帮助提高网络的泛化性能。LRN的作用就是，对位置(x, y)处的像素计算其与几个相邻的kernel maps的像素值的和，并除以这个和来归一化。

# VGGNet（Visual Geometry Group）

论文：https://arxiv.org/pdf/1409.1556.pdf

这个网络于2014年被牛津大学的Karen Simonyan 和Andrew Zisserman提出，主要特点是 “简洁，深度”。 深， 是因为VGG有19层，远远超过了它的前辈； 而简洁，则是在于它的结构上，一律采用stride为1的3×3filter，以及stride为2的2×2MaxPooling。所以虽然深，但是结构大家一眼就可以记住。

VggNet一共有六种不同的网络结构，但是每种结构都有含有５组卷积，每组卷积都使用３ｘ３的卷积核，每组卷积后进行一个２ｘ２最大池化，接下来是三个全连接层．在训练高级别的网络时，可以先训练低级别的网络，用前者获得的权重初始化高级别的网络，可以加速网络的收敛． 

图下所示，其中，网络结构D就是著名的VGG16，网络结构E就是著名的VGG19。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-5d310bcc20253dde3b20819ae4b53f5f.png)

VGGNet在训练时有一个小技巧，先训练级别A的简单网络，再复用A网络的权重来初始化后面的几个复杂模型，这样训练收敛的速度更快。在预测时，VGG采用Multi-Scale的方法，将图像scale到一个尺寸Q，并将图片输入卷积网络计算。然后在最后一个卷积层使用滑窗的方式进行分类预测，将不同窗口的分类结果平均，再将不同尺寸Q的结果平均得到最后结果，这样可提高图片数据的利用率并提升预测准确率。在训练中，VGGNet还使用了Multi-Scale的方法做数据增强，将原始图像缩放到不同尺寸S，然后再随机裁切224´224的图片，这样能增加很多数据量，对于防止模型过拟合有很不错的效果。 

在训练的过程中，比AlexNet收敛的要快一些，原因为：（1）使用小卷积核和更深的网络进行的正则化；（2）在特定的层使用了预训练得到的数据进行参数的初始化。

要点
1、仅使用3x3尺寸的filter与AlexNet的第一层11x11 filter 和ZF Net的7x7 filter 完全不同。作者的推理是两个3x3 conv层的组合具有5x5的有效感受野。这又可以模拟更大的 filter，同时保持较小filter尺寸的优势。其中一个好处是减少了参数的数量。此外，使用两个转换层，我们可以使用两个ReLU层而不是一个。  
2、3个背对背的conv层具有7x7的有效感受区域。  
3、随着每层输入卷的空间大小减小（转换层和池层的结果），当您沿着网络向下时，由于filter数量的增加，卷的深度会增加。  
4、有趣的是注意到每个maxpool层之后过滤器的数量翻倍。这加强了缩小空间尺寸的想法，但增加了深度。  
5、在图像分类和本地化任务方面都做得很好。作者使用一种本地化形式作为回归。  
6、使用Caffe工具箱构建模型。  
7、在训练期间使用scale jittering比例抖动作为一种数据增强技术。  
8、在每个转换层之后使用ReLU层并使用批量梯度下降进行训练。  
9、在4个Nvidia Titan Black GPU上训练了两到三周。  
10、LRN层作用不大（VGGNet不使用局部响应标准化(LRN)，这种标准化并不能在ILSVRC数据集上提升性能，却导致更多的内存消耗和计算时间。

# Google Inception Net

论文：https://www.cs.unc.edu/~wliu/papers/GoogLeNet.pdf

inception（也称GoogLeNet）是2014年Christian Szegedy提出的一种全新的深度学习结构，在这之前的AlexNet、VGG等结构都是通过增大网络的深度（层数）来获得更好的训练效果，但层数的增加会带来很多负作用，比如overfit、梯度消失、梯度爆炸等。inception的提出则从另一种角度来提升训练结果：能更高效的利用计算资源，在相同的计算量下能提取到更多的特征，从而提升训练结果。 

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-d7bc21df07dc7d4ffb38454d8f935879.png)

1、1x1卷积的作用

可以看到图1中有多个黄色的1x1卷积模块，这样的卷积有什么用处呢？

作用1：在相同尺寸的感受野中叠加更多的卷积，能提取到更丰富的特征。这个观点来自于Network in Network(NIN, https://arxiv.org/pdf/1312.4400.pdf)，图1里三个1x1卷积都起到了该作用。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-17d85785933f288a3494f0a6ceff8fa2.png)

图2:线性卷积和NIN结构对比

图2左侧是是传统的卷积层结构（线性卷积），在一个尺度上只有一次卷积；右图是Network in Network结构（NIN结构），先进行一次普通的卷积（比如3x3），紧跟再进行一次1x1的卷积，对于某个像素点来说1x1卷积等效于该像素点在所有特征上进行一次全连接的计算，所以右侧图的1x1卷积画成了全连接层的形式，需要注意的是NIN结构中无论是第一个3x3卷积还是新增的1x1卷积，后面都紧跟着激活函数（比如relu）。将两个卷积串联，就能组合出更多的非线性特征。举个例子，假设第1个3x3卷积＋激活函数近似于f1(x)=ax2+bx+c，第二个1x1卷积＋激活函数近似于f2(x)=mx2+nx+q，那f1(x)和f2(f1(x))比哪个非线性更强，更能模拟非线性的特征？答案是显而易见的。NIN的结构和传统的神经网络中多层的结构有些类似，后者的多层是跨越了不同尺寸的感受野（通过层与层中间加pool层），从而在更高尺度上提取出特征；NIN结构是在同一个尺度上的多层（中间没有pool层），从而在相同的感受野范围能提取更强的非线性。

作用2：使用1x1卷积进行降维，降低了计算复杂度。图2中间3x3卷积和5x5卷积前的1x1卷积都起到了这个作用。当某个卷积层输入的特征数较多，对这个输入进行卷积运算将产生巨大的计算量；如果对输入先进行降维，减少特征数后再做卷积计算量就会显著减少。下图是优化前后两种方案的乘法次数比较，同样是输入一组有192个特征、32x32大小，输出256组特征的数据，第一张图直接用3x3卷积实现，需要192x256x3x3x32x32=452984832次乘法；第二张图先用1x1的卷积降到96个特征，再用3x3卷积恢复出256组特征，需要192x96x1x1x32x32+96x256x3x3x32x32=245366784次乘法，使用1x1卷积降维的方法节省了一半的计算量。有人会问，用1x1卷积降到96个特征后特征数不就减少了么，会影响最后训练的效果么？答案是否定的，只要最后输出的特征数不变（256组），中间的降维类似于压缩的效果，并不影响最终训练的结果。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-aa22ba1675d7a2ce67d5d05fefdadac1.png)

图3:增加了1x1卷积后降低了计算量

2、多个尺寸上进行卷积再聚合

图2可以看到对输入做了4个分支，分别用不同尺寸的filter进行卷积或池化，最后再在特征维度上拼接到一起。这种全新的结构有什么好处呢？Szegedy从多个角度进行了解释：

解释1：在直观感觉上在多个尺度上同时进行卷积，能提取到不同尺度的特征。特征更为丰富也意味着最后分类判断时更加准确。

解释2：利用稀疏矩阵分解成密集矩阵计算的原理来加快收敛速度。举个例子下图左侧是个稀疏矩阵（很多元素都为0，不均匀分布在矩阵中），和一个2x2的矩阵进行卷积，需要对稀疏矩阵中的每一个元素进行计算；如果像右图那样把稀疏矩阵分解成2个子密集矩阵，再和2x2矩阵进行卷积，稀疏矩阵中0较多的区域就可以不用计算，计算量就大大降低。这个原理应用到inception上就是要在特征维度上进行分解！传统的卷积层的输入数据只和一种尺度（比如3x3）的卷积核进行卷积，输出固定维度（比如256个特征）的数据，所有256个输出特征基本上是均匀分布在3x3尺度范围上，这可以理解成输出了一个稀疏分布的特征集；而inception模块在多个尺度上提取特征（比如1x1，3x3，5x5），输出的256个特征就不再是均匀分布，而是相关性强的特征聚集在一起（比如1x1的的96个特征聚集在一起，3x3的96个特征聚集在一起，5x5的64个特征聚集在一起），这可以理解成多个密集分布的子特征集。这样的特征集中因为相关性较强的特征聚集在了一起，不相关的非关键特征就被弱化，同样是输出256个特征，inception方法输出的特征“冗余”的信息较少。用这样的“纯”的特征集层层传递最后作为反向计算的输入，自然收敛的速度更快。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-5387f7938a7b12ad5b751172f8865b3e.jpg)

图4: 将稀疏矩阵分解成子密集矩阵来进行计算

解释3：Hebbin赫布原理。Hebbin原理是神经科学上的一个理论，解释了在学习的过程中脑中的神经元所发生的变化，用一句话概括就是_fire togethter, wire together_。赫布认为“两个神经元或者神经元系统，如果总是同时兴奋，就会形成一种‘组合’，其中一个神经元的兴奋会促进另一个的兴奋”。比如狗看到肉会流口水，反复刺激后，脑中识别肉的神经元会和掌管唾液分泌的神经元会相互促进，“缠绕”在一起，以后再看到肉就会更快流出口水。用在inception结构中就是要把相关性强的特征汇聚到一起。这有点类似上面的解释2，把1x1，3x3，5x5的特征分开。因为训练收敛的最终目的就是要提取出独立的特征，所以预先把相关性强的特征汇聚，就能起到加速收敛的作用。

在inception模块中有一个分支使用了max pooling，作者认为pooling也能起到提取特征的作用，所以也加入模块中。注意这个pooling的stride=1，pooling后没有减少数据的尺寸。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-1a48a51580cbf1fbb1c3ac085969bb95.png)

GoogLeNet网络结构中有3个LOSS单元，这样的网络设计是为了帮助网络的收敛。在中间层加入辅助计算的LOSS单元，目的是计算损失时让低层的特征也有很好的区分能力，从而让网络更好地被训练。在论文中，这两个辅助LOSS单元的计算被乘以0.3，然后和最后的LOSS相加作为最终的损失函数来训练网络。

GoogLeNet还有一个闪光点值得一提，那就是将后面的全连接层全部替换为简单的全局平均pooling，在最后参数会变的更少。

要点



1、在整个架构中使用了9个Inception模块，总共超过100层！现在这很深......  
2、没有使用完全连接的层！他们使用平均水池，从7x7x1024 volume到1x1x1024 volume。这节省了大量参数。  
3、使用的参数比AlexNet少12倍。  
4、在测试过程中，创建了相同图像的多个作物，并将其输入网络，并对softmax概率进行平均，以便为我们提供最终解决方案。  
5、利用R-CNN的概念来检测它们的检测模型。  
6、Inception模块有更新版本（版本6和7）。  
7、接受“一周内几个高端GPU”的训练。  


# 微软ResNet残差神经网络

 论文：https://arxiv.org/pdf/1512.03385.pdf

最后要介绍的就是ResNet，于2015年由微软亚洲研究院的学者们提出。

前面讲了，CNN面临的一个问题就是，随着层数的增加，CNN的效果会遇到瓶颈，甚至会不增反降。这往往是梯度爆炸或者梯度消失引起的。

ResNet就是为了解决这个问题而提出的，因而帮助我们训练更深的网络。 它引入了一个 residual block（残差块）：

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-718353650ce4aaff236e099f5631f3c8.png)

ResNet结构：

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-49475124cf27692b34415067d37906d8.gif)

为什么这个残余块可能有效的另一个原因是在反向传播的向后传递期间，梯度将容易地流过图，因为我们具有分配梯度的加法运算。

要点

1、152层，“超深” 

2、有趣的是，在仅前两层之后，空间大小从224x224的输入体积压缩到56x56体积。

___3、___作者声称，普通网中层数的单纯增加会导致更高的训练和测试误差。

_4、_该小组尝试了1202层网络，但测试精度较低，可能是由于过度拟合。

__5、__在8 GPU机器上训练两到三周。

___6、___ResNet模型是我们目前拥有的最佳CNN架构，是残差学习理念的重大创新。

## **基于区域的CNNs (**[R-CNN](https://arxiv.org/pdf/1311.2524v5.pdf) **- 2013,** [Fast R-CNN](https://arxiv.org/pdf/1504.08083.pdf) **- 2015,** [Faster R-CNN](http://arxiv.org/pdf/1506.01497v3.pdf) **- 2015)**

 R-CNN的目的是解决物体检测问题。给定某个图像，我们希望能够在所有对象上绘制边界框。该过程可以分为两个通用组件，即区域建议步骤和分类步骤。

作者指出，任何类别不可知区域提案方法都应该适合。选择性搜索特别用于RCNN。选择性搜索执行生成具有包含对象的概率最高的2000个不同区域的功能。在我们提出一组区域提议之后，这些提议然后被“扭曲”成图像大小，该图像大小可以被馈送到训练有素的CNN（在这种情况下为AlexNet），其为每个区域提取特征向量。然后将该向量用作一组线性SVM的输入，这些线性SVM针对每个类进行训练并输出分类。矢量也被送入边界框回归器以获得最准确的坐标。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-e469914e7a4d0fff4c0a5a8e2b55be4f.png)

Fast R-CNN

由于3个主要问题，对原始模型进行了改进。 训练需要多个阶段（将SVM转换为边界框回归器），计算成本很高，而且速度极慢（RCNN每张图像需要53秒）。 快速R-CNN能够通过基本上共享不同提议之间的转换层的计算并交换生成区域提议和运行CNN的顺序来解决速度问题。 在这个模型中，图像首先通过ConvNet提供，区域提议的特征是从ConvNet的最后一个特征图获得的，最后我们还有完全连接的图层。 作为我们的回归和分类头。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-6cd3cff92d235b312c61b0afdd6b617e.png)

Faster R-CNN

更快的R-CNN可以抗衡R-CNN和快速R-CNN展示出来的的有些复杂的训练管道。 作者在最后一个卷积层之后插入区域提议网络（RPN）。 该网络只能查看最后一个卷积特征图并从中生成区域提议。 从该阶段开始，使用与R-CNN相同的管道（ROI池，FC，然后是分类和回归头）。

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-470f7ac8f5dbc34339bcb924ff3b962b.png)

## Generative Adversarial Networks (2014)

根据Yann LeCun的说法，这些网络可能是下一个重大发展。 在谈论本文之前，我们先谈谈对抗性的例子。 例如，让我们考虑一个在ImageNet数据上运行良好的经过训练的CNN。 让我们拍摄一个示例图像并应用扰动或略微修改，以便最大化预测误差。 因此，预测的对象类别改变，而与没有扰动的图像相比，图像本身看起来相同。 从最高级别来看，对抗性的例子基本上是欺骗ConvNets的图像。

 对抗性的例子（论文）肯定让很多研究人员感到惊讶，并迅速成为一个感兴趣的话题。现在让我们谈谈生成对抗性网络。让我们想一想两个模型，一个生成模型和一个判别模型。判别模型的任务是确定给定图像看起来是自然的（来自数据集的图像）还是看起来它是人工创建的。生成器的任务是创建图像，以便识别器被训练以产生正确的输出。这可以被认为是零和或极小极大的双人游戏。本文中使用的类比是生成模型就像“一个伪造者团队，试图生产和使用虚假货币”，而歧视模型就像“警察，试图检测伪造货币”。当鉴别器试图不被发生器愚弄时，发生器试图欺骗鉴别器。随着模型的训练，两种方法都得到了改进，直到“伪造品与真品无法区分”为止。

 ![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-594b356b94df85c481289137bc87873a.png)

## [Generating Image Descriptions](https://arxiv.org/pdf/1412.2306v2.pdf) **(2014)**

 当您将CNN与RNN结合使用时会发生什么（不，您没有R-CNN，对不起）？但是您确实得到了一个非常棒的应用程序。 本文由Andrej Karpathy（我个人最喜欢的作者之一）和李飞飞撰写，探讨了CNN与双向RNN（回归神经网络）的结合，以生成不同图像区域的自然语言描述。 基本上，模型能够接收图像，并输出：

![](cnn%E5%8F%91%E5%B1%95%E7%BB%BC%E8%BF%B0/1625905160-c33378871c845b7ab53a6e551c5b06c8.png)

　　这真是太不可思议了。让我们来看看它与普通CNN的比较。对于传统的CNN，在训练数据中存在与每个图像相关联的单个清晰标签。本文中描述的模型具有训练示例，其具有与每个图像相关联的句子（或标题）。这种类型的标签称为弱标签，其中句子的片段指的是图像的（未知）部分。使用这种训练数据，深度神经网络“推断出句子段与他们描述的区域之间的潜在对齐”（引自论文）。另一个神经网络将图像作为输入并在文本中生成描述。让我们单独看看两个组件，对齐和生成。

对齐模型

        该部分模型的目标是能够对齐视觉和文本数据（图像及其句子描述）。该模型的工作原理是接受一个图像和一个句子作为输入，其中输出是它们匹配程度的分数（现在，Karpathy指的是一个不同的论文，其中详细说明了它的工作原理。这个模型是在兼容和不兼容的情况下训练的图像 - 句子对）。

        现在让我们考虑表示图像。第一步是将图像输入R-CNN以检测单个物体。这个R-CNN接受了ImageNet数据的培训。顶部19（加上原始图像）对象区域嵌入到500维空间中。现在我们为每个图像提供20个不同的500维向量（在论文中用v表示）。我们有关于图像的信息。现在，我们想要有关该句子的信息。我们要在同一个多模式空间中嵌入单词。这是通过使用双向递归神经网络完成的。从最高级别，这用于说明关于给定句子中的单词的上下文的信息。由于关于图片和句子的信息都在同一空间，我们可以计算内部产品以显示相似性的度量。

生成模型

        对齐模型的主要目的是创建一个数据集，其中有一组图像区域（由RCNN找到）和相应的文本（感谢BRNN）。现在，生成模型将从该数据集中学习，以生成给定图像的描述。该模型接收图像并通过CNN馈送。当完全连接层的输出成为另一个RNN的输入时，忽略softmax层。对于那些不熟悉RNN的人来说，他们的功能是基本上形成句子中不同单词的概率分布（RNN也需要像CNN一样训练）。

 ![](assets/1625905160-9215197a1ec15d36f3ffc5544d6a6bf5.png)